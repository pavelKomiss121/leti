# Лабораторная работа 1. Генерация модельных наборов данных

**Цель:** получить навыки работы с массивами NumPy и написать функции на Python для генерации массивов данных с заданным распределением.

---

## Как запустить

Из корня проекта `leti`:

```bash
pip install -r requirements.txt
python -m lab1.main
```

Либо из папки `lab1`:

```bash
cd lab1
python main.py
```

Графики сохраняются в текущую директорию (откуда запущен скрипт) и выводятся на экран.

---

## Структура и назначение файлов

| Файл | Назначение |
|------|------------|
| `DataGenerator.py` | Функции генерации данных: `norm_dataset` (нормальное распределение) и `nonlinear_dataset_5` (вариант 5 — вложенные области). |
| `main.py` | Основной скрипт: вызов генераторов, разбиение на train/test, построение гистограмм и скатерограмм. |

---

## Пошаговое объяснение кода (для тех, кто привык к Java)

### 1. Параметры и вызов генератора

В `main.py` задаются:

- **N** — число объектов в каждом классе (1000).
- **mu0, mu1** — списки средних по признакам для класса 0 и класса 1. Аналог: три координаты центра «облака» точек в 3D.
- **sigma0, sigma1** — списки стандартных отклонений по каждому признаку. Чем больше значение, тем сильнее разброс точек.

В Java это было бы что-то вроде `double[] mu0 = {0, 2, 3};`. В Python списки: `mu0 = [0, 2, 3]`.

Вызов `dg.norm_dataset(mu, sigma, N)` возвращает четыре объекта: объединённые и перемешанные признаки **X**, метки **Y**, а также **class0** и **class1** для построения графиков (без перемешивания).

---

### 2. Как устроены данные в `norm_dataset`

- **class0** и **class1** — это матрицы размера `(N, col)`: N строк (объектов), col столбцов (признаков). В Java это был бы `double[][]` или список массивов.

- По каждому признаку точки генерируются из нормального распределения с своими средним и дисперсией:
  - `np.random.normal(mu0[i], sigma0[i], (N, 1))` — один столбец из N чисел.
  - Цикл с **i от 1 до col-1** добавляет остальные столбцы. Нумерация с 1, потому что первый столбец уже создан до цикла.

- **np.hstack((class0, v0))** — «склеивание» матриц по горизонтали: к уже имеющимся столбцам добавляется новый. Аналог: добавить новый столбец в таблицу.

- **Y0** и **Y1** — метки класса: массив нулей и массив единиц (тип bool). Размер каждого — (N, 1).

- **X = np.vstack((class0, class1))** — объединение по вертикали: сначала все объекты класса 0, потом класса 1. Получается матрица (2*N, col).

- **Y = np.vstack((Y0, Y1)).ravel()** — метки в том же порядке; **ravel()** превращает матрицу в одномерный массив (2*N,). Классификаторы в Python часто ожидают метки именно в виде одномерного массива.

- **Shuffle:** создаётся массив индексов `arr = np.arange(2*N)`, он перемешивается. Затем и **X**, и **Y** переставляются по этим индексам: `X = X[arr]`, `Y = Y[arr]`. Порядок строк в X и порядок элементов в Y остаются согласованными — объект и его метка не разъезжаются.

---

### 3. Разбиение на обучающую и тестовую подвыборки (70/30)

После shuffle данные уже в случайном порядке. Берётся:

- **train_count = round(0.7 * 2 * N)** — 70% от общего числа объектов.
- **Xtrain** — первые `train_count` строк X; **Xtest** — остальные.
- **Ytrain** и **Ytest** — те же индексы для меток.

Обучающая выборка используется для «обучения» модели, тестовая — для оценки качества (в этой работе только генерация и визуализация, классификаторы не обучаются).

---

### 4. Визуализация

- **Гистограммы:** для каждого признака (индекс i от 0 до col-1) на одном графике строятся два столбчатых распределения — по классу 0 и по классу 1. По перекрытию столбиков можно судить о «пересекаемости» классов по этому признаку. Файлы: `hist_1.png`, `hist_2.png`, `hist_3.png`.

- **Скатерограмма (нормальный датасет):** точки в осях «признак 1» и «признак 3». Каждый класс своим цветом. Показывает, насколько классы смешаны в плоскости двух признаков. Файл: `scatter_norm.png`.

- **Скатерограмма нелинейного датасета:** два признака (X и Y), два класса — вложенные области. Файл: `scatter_nonlinear_5.png`.

Подписи осей и заголовки задаются через `plt.xlabel`, `plt.ylabel`, `plt.title`.

---

### 5. Функция `nonlinear_dataset_5`

Реализует вариант 5 из приложения А: один класс образует большую область, второй — меньшую область внутри неё (форма «миндалина/сердце» упрощена до вложенных эллипсов).

- **Класс 0 (внешний):** точки попадают внутрь эллипса с полуосями 2.5 и 1.8. Генерация методом отбора: случайная точка в прямоугольнике проверяется по условию «внутри эллипса»; если да — добавляется в выборку. Добавляется небольшой шум.

- **Класс 1 (внутренний):** то же самое для меньшего эллипса (полуоси 1.0 и 0.6). Оба эллипса с центром в (0, 0).

- Далее, как и в `norm_dataset`: объединение X и Y, перемешивание, возврат X, Y, class0, class1. Формат совместим с основным скриптом и визуализацией.

---

## Создаваемые файлы графиков

| Файл | Содержание |
|------|------------|
| `hist_1.png`, `hist_2.png`, `hist_3.png` | Гистограммы по каждому признаку нормального датасета (оба класса на одном графике). |
| `scatter_norm.png` | Скатерограмма нормального датасета (признаки 1 и 3). |
| `scatter_nonlinear_5.png` | Скатерограмма нелинейного датасета варианта 5 (вложенные области). |

Файлы появляются в той папке, из которой был запущен скрипт (корень `leti` или папка `lab1`).

---

## Кратко про используемые функции NumPy (аналогия с Java)

- **np.hstack** — склеивание массивов по горизонтали (добавление столбцов).
- **np.vstack** — склеивание по вертикали (добавление строк).
- **ravel()** — превращение матрицы в одномерный массив без копирования, где возможно.
- **X[arr]** — индексация по массиву индексов: из X выбираются строки в порядке, заданном arr.

Ответы на вопросы для самоконтроля см. в файле **QUESTIONS_ANSWERS.md**.
